import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/evaluations/entities/player_evaluation.dart';
import '../../domain/evaluations/entities/evaluation_score.dart';
import '../../domain/evaluations/repositories/player_evaluations_repository.dart';
import 'player_evaluations_state.dart';

class PlayerEvaluationsNotifier extends StateNotifier<PlayerEvaluationsState> {
  final PlayerEvaluationsRepository _repository;

  PlayerEvaluationsNotifier(this._repository)
      : super(const PlayerEvaluationsInitial());

  Future<void> loadEvaluationsForPlayer(String playerId) async {
    state = const PlayerEvaluationsLoading();
    try {
      final evaluations = await _repository.listEvaluationsForPlayer(playerId);
      final latestEvaluation =
          await _repository.getLatestEvaluationForPlayer(playerId);

      List<EvaluationScore> latestScores = [];
      if (latestEvaluation != null) {
        latestScores =
            await _repository.getScoresForEvaluation(latestEvaluation.id);
      }

      state = PlayerEvaluationsLoaded(
        evaluations: evaluations,
        latestEvaluation: latestEvaluation,
        latestScores: latestScores,
      );
    } catch (e) {
      state = PlayerEvaluationsError(e.toString());
    }
  }

  Future<void> createEvaluation({
    required String playerId,
    required String evaluatorId,
    required DateTime evaluationDate,
    String? generalNotes,
    required Map<String, int> scores,
    Map<String, String>? scoreNotes,
  }) async {
    state = const PlayerEvaluationSaving();
    try {
      // Create the evaluation
      final evaluation = PlayerEvaluation(
        id: '', // Will be generated by DB
        playerId: playerId,
        evaluatorId: evaluatorId,
        evaluationDate: evaluationDate,
        generalNotes: generalNotes,
        createdAt: DateTime.now(),
      );

      final savedEvaluation = await _repository.createEvaluation(evaluation);

      // Create the scores
      final evaluationScores = scores.entries.map((entry) {
        return EvaluationScore(
          id: '', // Will be generated by DB
          evaluationId: savedEvaluation.id,
          criterionId: entry.key,
          score: entry.value,
          notes: scoreNotes?[entry.key],
          createdAt: DateTime.now(),
        );
      }).toList();

      await _repository.createScores(evaluationScores);

      state = PlayerEvaluationSaved(savedEvaluation);

      // Reload evaluations for this player
      await loadEvaluationsForPlayer(playerId);
    } catch (e) {
      state = PlayerEvaluationsError(e.toString());
    }
  }

  Future<void> deleteEvaluation(String evaluationId, String playerId) async {
    try {
      await _repository.deleteEvaluation(evaluationId);
      await loadEvaluationsForPlayer(playerId);
    } catch (e) {
      state = PlayerEvaluationsError(e.toString());
    }
  }

  Future<List<EvaluationScore>> getScoresForEvaluation(
      String evaluationId) async {
    return await _repository.getScoresForEvaluation(evaluationId);
  }
}
